# ---   IMPORTS   --- #
# ------------------- #
from src.tests.vl3d_test import VL3DTest
from src.model.deeplearn.layer.features_upsampling_layer import \
    FeaturesUpsamplingLayer
from src.utils.ptransf.receptive_field_fps import ReceptiveFieldFPS
from scipy.spatial import KDTree as KDT
import numpy as np
import tensorflow as tf


# ---   CLASS   --- #
# ----------------- #
class FeaturesUpsamplingLayerTest(VL3DTest):
    """
    :author: Alberto M. Esmoris Pena

    Features upsampling layer test that checks the operations of a
    features upsampling layer yield the expected results.
    """
    # ---   INIT   --- #
    # ---------------- #
    def __init__(self):
        super().__init__('Features upsampling layer test')
        self.eps = 1e-5  # Decimal tolerance for error checks

    # ---   TEST INTERFACE   --- #
    # -------------------------- #
    def run(self):
        """
        Run features upsampling layer test.

        :return: True if :class:`.FeaturesUpsamplingLayer` works as expected
            for the test cases, False otherwise.
        :rtype: bool
        """
        # Generate test data
        points_per_axis = 10
        num_points = points_per_axis**3
        num_encoding_neighbors = 4
        num_features = 5
        t = np.linspace(0, 2, points_per_axis)
        o = np.ones(3)
        X1 = np.array([
            [x, y, z]
            for x in t for y in t for z in t
        ])
        F1 = np.random.normal(0, 1, (num_points, num_features))
        X2 = X1 / np.array([1.0, 1.0, 2.0])
        F2 = np.random.normal(0, 1, (num_points, num_features))
        rf1 = ReceptiveFieldFPS(
            num_points=num_points//3,
            num_encoding_neighbors=num_encoding_neighbors,
            fast=False
        )
        rf1.fit(X1, o)
        rf2 = ReceptiveFieldFPS(
            num_points=num_points//3,
            num_encoding_neighbors=num_encoding_neighbors,
            fast=False
        )
        rf2.fit(X2, o)
        X1b = rf1.centroids_from_points(X1)  # Previous depth structure space
        X2b = rf2.centroids_from_points(X2)
        NU1 = rf1.M  # Indexing matrix governing the upsampling
        NU2 = rf2.M
        inputs = [
            np.array([X1b, X2b]),
            np.array([rf1.center_and_scale(X1), rf2.center_and_scale(X2)]),
            np.array([F1, F2]),
            np.array([NU1, NU2])
        ]
        # Instantiate features upsampling layers
        fdl_gauss = FeaturesUpsamplingLayer(filter='gaussian')
        fdl_mean = FeaturesUpsamplingLayer(filter='mean')
        fdl_nearest = FeaturesUpsamplingLayer(filter='nearest')
        # Compute gaussian and mean upsampling
        with tf.device("cpu:0"):
            fdl_gauss_out = fdl_gauss.call(inputs)
            fdl_mean_out = fdl_mean.call(inputs)
            fdl_nearest_out = fdl_nearest.call(inputs)
        # Validate
        valid = True
        valid = valid and self.validate_mean_upsampling(
            inputs, num_encoding_neighbors, fdl_mean_out
        )
        valid = valid and self.validate_gaussian_upsampling(
            inputs, num_encoding_neighbors, fdl_gauss_out
        )
        valid = valid and self.validate_nearest_upsampling(
            inputs, num_encoding_neighbors, fdl_nearest_out
        )
        # Return
        return valid

    # ---  UTIL METHODS  --- #
    # ---------------------- #
    def validate_mean_upsampling(self, inputs, nneighs, fdl_mean_out):
        """
        Check whether the mean-based upsampling layer yielded the expected
        output (True) or not (False).

        :param inputs: The inputs to the layer.
        :param nneighs: The number of encoding neighbors.
        :param fdl_mean_out: The output generated by the layer.
        :return: True if the output is okay, False otherwise.
        """
        X_batch, Xb_batch, F_batch, NU_batch = inputs
        num_elems_in_batch = X_batch.shape[0]
        fdl_mean_out = np.array(fdl_mean_out)
        for k in range(num_elems_in_batch):
            X, Xb, F, NU = X_batch[k], Xb_batch[k], F_batch[k], NU_batch[k]
            kdt = KDT(X)
            I = kdt.query(Xb, k=nneighs)[1]
            ref_out = np.mean(F[I], axis=1)
            if not np.allclose(fdl_mean_out[k], ref_out, atol=self.eps, rtol=0):
                return False
        return True

    def validate_gaussian_upsampling(
        self, inputs, nneighs, fdl_gauss_out
    ):
        """
        Check whether the gaussian-based upsampling layer yielded the
        expected output (True) or not (False).

        :param inputs: The inputs to the layer.
        :param nneighs: The number of encoding neighbors.
        :param fdl_gaussian_out: The output generated by the layer.
        :return: True if the output is okay, False otherwise.
        """
        X_batch, Xb_batch, F_batch, NU_batch = inputs
        num_elems_in_batch = X_batch.shape[0]
        fdl_gauss_out = np.array(fdl_gauss_out)
        for k in range(num_elems_in_batch):
            X, Xb, F, NU = X_batch[k], Xb_batch[k], F_batch[k], NU_batch[k]
            kdt = KDT(X)
            I = kdt.query(Xb, k=nneighs)[1]
            XI = X[I]
            D_sq = np.sum(np.square(
                np.transpose(np.transpose(XI, [1, 0, 2])-Xb, [1, 0, 2])),
                axis=2
            )
            omega_sq = np.max(D_sq, axis=1)
            gaussians = np.exp(D_sq/np.expand_dims(omega_sq, 1))
            gaussian_norms = np.sum(gaussians, axis=1)
            ref_out = np.sum(np.expand_dims(gaussians, axis=2)*F[I], axis=1)
            ref_out = ref_out / np.expand_dims(gaussian_norms, axis=1)
            if not np.allclose(fdl_gauss_out[k], ref_out, atol=self.eps, rtol=0):
                return False
        return True

    def validate_nearest_upsampling(
        self, inputs, nneighs, fdl_nearest_out
    ):
        """
        Check whether the nearest neighbor upsampling layer yielded the
        expected output (True) or not (False).

        :param inputs: The inputs to the layer.
        :param nneighs: The number of encoding neighbors (IGNORED).
        :param fdl_nearest_out: The output generated by the layer.
        :return: True if the output is okay, False otherwise.
        """
        X_batch, Xb_batch, F_batch, NU_batch = inputs
        num_elems_in_batch = X_batch.shape[0]
        fdl_nearest_out = np.array(fdl_nearest_out)
        for k in range(num_elems_in_batch):
            X, Xb, F, NU = X_batch[k], Xb_batch[k], F_batch[k], NU_batch[k]
            kdt = KDT(X)
            I = kdt.query(Xb, k=1)[1]
            ref_out = F[I]
            if not np.allclose(fdl_nearest_out[k], ref_out, atol=self.eps, rtol=0):
                return False
        return True
